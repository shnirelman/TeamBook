<div th:fragment="euclid">
  <h1 class="article_h1"> Алгоритм Евклида нахождения НОД </h1>

  <div class="article_table_of_content">
    <h2>Содержание</h2>
    <ol>
      <li><a href="#prerequisites">Предварительные требования к читателю</a></li>
      <li><a href="#problem">Постановка задачи</a></li>
      <li><a href="#builtin">Использование встроенной функции</a></li>
      <li><a href="#idea">Идея алгоритма</a></li>
      <li><a href="#optimization">Ускорение алгоритма</a></li>
      <li><a href="#how-to-implement">Как можно реализовать алгоритм</a></li>
      <li><a href="#implementation">Реализация</a></li>
      <li><a href="#applications">Применения</a></li>
    </ol>
  </div>

  <h2 class="article_h2" id="prerequisites">Предварительные требования к читателю</h2>
  <ul>
    <li>Понятие наибольшего общего делителя</li>
  </ul>

  <h2 class="article_h2" id="problem">Постановка задачи</h2>
  Даны два числа \(x, y\). Найти их наибольший общий делитель.
  \((x, y <= 10^9)\)

  <h2 class="article_h2" id="builtin">Использование встроенной функции</h2>
  В языке C++ есть функция \(\_\_gcd(x, y)\) (нужно подключить библиотеку algorithm),
  так что НОД можно искать и без этого алгоритма.

  <h2 class="article_h2" id="idea">Идея алгоритма</h2>
  Пусть \(x <= y\). Тогда из \(y\) можно вычесть \(x\), и НОД не поменяется.
  <p>Получаем следующий алгоритм: вычитать из большего числа меньшее; повторять эту итерацию, пока числа не станут равны.
  В конце получим, что оба числа равны НОД.
  <p>Пример: найдём НОД чисел \(15\) и \(21\).
  НОД(\(15, 21\)) = НОД(\(15, 6\)) = НОД(\(9, 6\)) = НОД(\(3, 6\)) = НОД(\(3, 3\)) = \(3\).
  <p>Но такой алгоритм может медленно работать (пример - найти НОД(\(1, 1000000000\))).

  <h2 class="article_h2" id="optimization">Ускорение алгоритма</h2>
  В таком виде алгоритм медленно работает, когда одно число сильно больше другого. Тогда из первого нужно
  много раз вычитать второе. Но эту последовательность вычитаний можно заменить взятием остатка от деления.
  Например, если нужно найти НОД(\(21, 6\)), то по алгоритму с вычитаниями получаем:
  НОД(\(21, 6\)) = НОД(\(15, 6\)) = НОД(\(9, 6\)) = НОД(\(3, 6\)) = НОД(\(3, 3\)) = \(3\).<br>
  Вместо того, чтобы вычитать \(6\) из \(21\) много раз, можно сразу заменить \(21\) на \(21\) mod \(6 = 3\).<br>
  Теперь считаем НОД(\(3, 6\)). Заменяем \(6\) на остаток от деления на \(3\), т.е. \(0\).<br>
  Получилась проблема: алгоритм проскочил через состояние НОД(\(3, 3\)), которое было конечным в алгоритме с вычитаниями.
  Теперь нужно найти НОД(\(3, 0\)).<br>
  Решение проблемы: теперь будем завершать алгоритм, когда одно из чисел равно нулю. Тогда НОД равен другому числу.
  Таким образом, НОД(\(21, 6\)) = НОД(\(3, 6\)) = НОД(\(3, 0\)) = \(3\).

  <h2 class="article_h2" id="how-to-implement">Как можно реализовать алгоритм</h2>
  Чтобы не делать проверку на то, какое из двух чисел больше, можно всегда делить второе число на первое, но
  после каждой итерации менять числа местами.<br>
  Пример: НОД(\(21, 6\)) = НОД(\(6\) mod \(21\), \(21\)) =
  НОД(\(6, 21\)) = НОД(\(21\) mod \(6, 6\)) =
  НОД(\(3, 6\)) = НОД(\(6\) mod \(3, 3\)) =
  НОД(\(0, 3\)) = \(3\)
  <p>Таким образом, на кажой итерации НОД(\(x, y\)) превращается в НОД(\(y\) mod \(x, x\)).
  Алгоритм нужно завершить, когда \(x = 0\), тогда искомый НОД равен \(y\).

  <h2 class="article_h2" id="implementation">Реализация</h2>
  <!-- <div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">vector<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> p(n <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">0</span>);
<span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> n; i<span style="color: #333333">++</span>)
  p[i <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>] <span style="color: #333333">=</span> p[i] <span style="color: #333333">+</span> a[i];
</pre></div> --->
  <pre><code class="language-cpp">
    int gcd(int x, int y) {
      if(x == 0)
        return y;
      return gcd(y % x, x);
    }
  </code></pre>

  <h2 class="article_h2" id="applications">Применения</h2>
  Если нужно найти НОК (наименьшее общее кратное), то можно воспользоваться формулой
  \(НОК(x, y) = x * y / НОД(x, y)\)

</div>