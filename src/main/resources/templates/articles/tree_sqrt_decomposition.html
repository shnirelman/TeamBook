<div th:fragment="tree_sqrt_decomposition">
    <h1 class="article_h1"> Корневая декомпозиция на дереве </h1>

    <div class="article_table_of_content">
        <h2>Содержание</h2>
        <ol>
            <li><a href="#prerequisites">Предварительные требования к читателю</a></li>
            <li><a href="#представление-дерева-в-виде-групп-вершин">Представление дерева в
                виде групп вершин</a></li>
            <li><a href="#решение-задач-с-помощью-описанного-представления">Решение задач
                с помощью описанного представления</a></li>
            <li><a href="#запросы-на-поддеревьях">Запросы на поддеревьях</a></li>
            <li><a href="#поддеревья-некорневого-дерева">Поддеревья некорневого
                дерева</a></li>
            <li><a href="#добавление-листа">Добавление листа</a></li>
        </ol>
    </div>

    <h2 class="article_h2" id="prerequisites">Предварительные требования к читателю</h2>
    <ul>
        <li>Обход в глубину</li>
        <li>Корневая декомпозиция</li>
        <li>Алгоритм МО</li>
    </ul>

    <h2 class="article_h2" id="представление-дерева-в-виде-групп-вершин">Представление дерева в
        виде групп вершин</h2>
    <h3 class="article_h3" id="построение-представления">Построение представления</h3>
    <p>Разделим вершины корневого дерева из <span
            class="math inline"><em>N</em></span> вершин на группы так, чтобы
        выполнялись следующие условия для некоторого параметра <span
                class="math inline"><em>H</em></span> (который в общем случае является
        функцией от количества вершин в дереве: <span
                class="math inline"><em>H</em> = <em>H</em>(<em>N</em>)</span>):</p>
    <ol>
        <li><p><span id="itm:condition1" label="itm:condition1"></span> Каждая
            вершина относится ровно к одной группе.</p></li>
        <li><p><span id="itm:condition2" label="itm:condition2"></span>
            Симметрическая разность поддеревьев любых двух вершин одной группы
            состоит из <span class="math inline"><em>O</em>(<em>H</em>)</span>
            вершин.</p></li>
        <li><p><span id="itm:condition3" label="itm:condition3"></span>
            Количество групп равно <span
                    class="math inline">\(O(\frac{N}{H})\)</span>.</p></li>
    </ol>
    <p>Чтобы построить группы, удовлетворяющие этим условиям, сначала
        разделим все вершины на легкие и тяжелые: назовем вершину <span
                class="math inline"><em>v</em></span> легкой, если <span
                class="math inline"><em>s</em><em>z</em>(<em>v</em>) &lt; <em>H</em></span>,
        в противном случае назовем вершину <span
                class="math inline"><em>v</em></span> тяжелой.</p>

    <div id="lem:heavy_anc" class="lemma">
        <p><strong>Лемма 1</strong>. <em>Предок тяжелой вершины является тяжелой
            вершиной.</em></p>
        <div class="proof">
            <p><em><em>Proof.</em> Пусть вершина <span
                    class="math inline"><em>a</em><em>n</em><em>c</em></span> является
                предком тяжелой вершины <span class="math inline"><em>v</em></span>.
                Тогда поддерево вершины <span
                        class="math inline"><em>a</em><em>n</em><em>c</em></span> включает в
                себя все поддерево вершины <span class="math inline"><em>v</em></span>:
                <span
                        class="math inline"><em>T</em>(<em>v</em>) ⊂ <em>T</em>(<em>a</em><em>n</em><em>c</em>)</span>,
                следовательно его размер не меньше размера поддерева вершины <span
                        class="math inline"><em>v</em></span>, то есть не меньше <span
                        class="math inline"><em>H</em></span>, следовательно вершина <span
                        class="math inline"><em>a</em><em>n</em><em>c</em></span> является
                тяжелой. ◻</em></p>
        </div>
    </div>
    <p>Объединим все легкие вершины в одну группу. Назовем эту группу
        легкой. Заметим, что для легкой вершины выполняется условие <a
                href="#itm:condition2" data-reference-type="ref"
                data-reference="itm:condition2">[2]</a>, так как размер
        поддерева любой легкой вершины меньше <span
                class="math inline"><em>H</em></span>, то симметрическая разность
        поддеревьев любых двух легких вершин будет иметь размер меньше <span
                class="math inline">2 ⋅ <em>H</em></span>, то есть он будет равен <span
                class="math inline"><em>O</em>(<em>H</em>)</span>.</p>
    <p>Теперь разделим на группы тяжелые вершины. Полученные группы назовем
        тяжелыми группами. Будем строить эти группы последовательно, пока
        остаются еще не распределенные на группы тяжелые вершины. Для этого
        среди еще не распределенных тяжелых вершин возьмем самую глубокую, то
        есть вершину с максимальным значением <span
                class="math inline"><em>d</em>(<em>v</em>)</span>. Если таких несколько,
        то среди подходящих возьмем вершину с меньшим номером.</p>
    <p>Создадим новую группу, состоящую пока что только из этой вершины. Эту
        вершину назовем листом этой тяжелой группы. Пока текущая вершина не
        является корнем дерева и разница размеров поддеревьев листа этой тяжелой
        группы и родителя текущей вершины не превосходит <span
                class="math inline"><em>H</em></span>, будем переходить в родителя
        текущей вершины и добавлять его в группу. Последнюю добавленную в
        тяжелую группу вершину назовем корнем этой тяжелой группы.</p>
    <p>Заметим, что любые две вершины построенной группы являются парой из
        предка <span class="math inline"><em>a</em><em>n</em><em>c</em></span> и
        потомка <span class="math inline"><em>d</em><em>e</em><em>s</em></span>,
        поэтому размер симметрической разности их поддеревьев равен разности
        <span
                class="math inline"><em>s</em><em>z</em>(<em>a</em><em>n</em><em>c</em>) − <em>s</em><em>z</em>(<em>d</em><em>e</em><em>c</em>)</span>,
        которая не превосходит разности <span
                class="math inline"><em>s</em><em>z</em>(<em>a</em><em>n</em><em>c</em>) − <em>s</em><em>z</em>(<em>l</em><em>e</em><em>a</em><em>f</em>)</span>,
        где <span
                class="math inline"><em>l</em><em>e</em><em>a</em><em>f</em></span> —
        лист построенной тяжелой группы. Осталось заметить, что последняя
        разность не превосходит <span class="math inline"><em>H</em></span> по
        построению, а следовательно для построенной тяжелой группы выполняется
        условие <a href="#itm:condition2" data-reference-type="ref"
                   data-reference="itm:condition2">[2]</a>.</p>
    <p>Реализация описанного алгоритма на <code class="c">C++</code>:</p>
    <pre><code class="language-cpp">vector&ltpair&ltint, int>> ord;
for(int i = 0; i < n; i++) {
    if(sz[i] >= H) {
        ord.emplace_back(-d[i], i);
        group[i] = -1;
    } else {
        group[i] = 0;
    }

}

counting_sort(ord.begin(), ord.end());

int cur_ind = 1;
for(auto [depth, v] : ord) {
    if(group[v] == -1) {
        group_leaf[cur_ind] = v;
        while(H >= sz[v] - sz[group_leaf[cur_ind]]) {
            group[v] = cur_ind;
            group_root[cur_ind] = v;

            if(v == root)
                break;
            else
                v = par[v];
        }

        cur_ind++;
    }
}

int group_count = cur_ind;</code></pre>
    <p>Здесь <code class="c">counting_sort</code> стабильная сортировка
        подсчетом по первому элементу пары.</p>
    <div class="lemma">
        <p><strong>Лемма 2</strong>. <em>Описанный алгоритм конечен.</em></p>
        <div class="proof">
            <p><em><em>Proof.</em> При создании одной тяжелой группы мы всегда
                переходим от сына к родителю, поэтому через конечное количество шагов мы
                попадем в корень дерева (если не закончим построение этой группы до
                этого) и закончим построение этой тяжелой группы.</em></p>
            <p><em>Каждый раз, когда мы создаем новую тяжелую группу, количество
                нераспределенных тяжелых вершин уменьшается хотя бы а <span
                        class="math inline">1</span>, следовательно будет создано лишь конечное
                количество групп, каждая из которых будет построена за конечное число
                операций, следовательно алгоритм конечен. ◻</em></p>
        </div>
    </div>
    <div id="the:main1" class="theorem">
        <p><strong>Теорема 3</strong>. <em>Построенные группы удовлетворяют
            условию <a href="#itm:condition1" data-reference-type="ref"
                       data-reference="itm:condition1">[1]</a>.</em></p>
        <div class="proof">
            <p><em><em>Proof.</em> По построению все легкие вершины относятся к хотя
                бы одной группе — легкой группе. Докажем, что ни одна легкая вершина не
                входит ни в одну тяжелую группу. Для этого заметим, что построение любой
                тяжелой группы начинается с тяжелой вершины, после чего в нее
                добавляются некоторые ее предки (возможно все или ни один из них),
                которые по лемме <a href="#lem:heavy_anc" data-reference-type="ref"
                                    data-reference="lem:heavy_anc">1</a> также являются тяжелыми вершинами.
                Таким образом, в тяжелые группы добавляются только тяжелые вершины, а
                значит все легкие вершины относятся ровно к одной группе — легкой
                группе.</em></p>
            <p><em>Теперь докажем утверждение теоремы для тяжелых вершин. Так как
                при построении мы строим тяжелые группы пока есть еще не распределенные
                тяжелые вершины, то каждая тяжелая вершина попала хотя бы в одну группу.
                Теперь докажем, что каждая тяжелая вершина попала в не более чем одну
                тяжелую группу.</em></p>
            <p><em>Так как при построении одной тяжелой группы мы двигаемся всегда
                вверх: от потомков к предкам, то мы не могли поместить одну вершину в
                одну тяжелую группу более одного раза. Докажем теперь, что одна вершина
                не могла оказаться сразу в двух группах. От противного, рассмотрим
                первый момент времени, в который мы добавили вершину в группу во второй
                раз. Пусть эта вершина <span class="math inline"><em>v</em></span> и в
                первый раз, когда мы ее добавили в группу, в которую мы пришли из ее
                сына <span class="math inline"><em>u</em><sub>1</sub></span>, а во
                второй — из сына <span
                        class="math inline"><em>u</em><sub>2</sub></span>. Отметим, что в оба
                раза вершина <span class="math inline"><em>v</em></span> не могла быть
                листом тяжелой группы: во второй раз — потому что по построению для
                листа мы выбираем еще не использованную вершину, в первый раз  потому
                что по построению мы выбираем в качестве листа самую глубокую из
                неиспользованных тяжелых вершин, в то время как на момент первого
                добавления вершины <span class="math inline"><em>v</em></span> в группу
                вершина <span class="math inline"><em>u</em><sub>2</sub></span> еще не
                была использована. Таким образом, определение вершин <span
                        class="math inline"><em>u</em><sub>1</sub></span> и <span
                        class="math inline"><em>u</em><sub>2</sub></span> корректно. Так как
                поддеревья <span
                        class="math inline"><em>T</em>(<em>u</em><sub>1</sub>)</span> и <span
                        class="math inline"><em>T</em>(<em>u</em><sub>2</sub>)</span> не
                пересекаются и <span
                        class="math inline"><em>T</em>(<em>u</em><sub>1</sub>) ⊂ <em>T</em>(<em>v</em>)</span>
                и <span
                        class="math inline"><em>T</em>(<em>u</em><sub>2</sub>) ⊂ <em>T</em>(<em>v</em>)</span>
                и вершина <span class="math inline"><em>u</em><sub>2</sub></span> —
                тяжелая, то <span
                        class="math display">|<em>T</em>(<em>v</em>)△<em>T</em>(<em>u</em><sub>1</sub>)| ≥ |<em>T</em>(<em>u</em><sub>2</sub>)| + 1 ≥ <em>H</em> + 1</span>
                Следовательно при построении тяжелой группы, в которую входит вершина
                <span class="math inline"><em>u</em><sub>1</sub></span>, мы не могли
                добавить вершину <span class="math inline"><em>v</em></span> —
                противоречие. ◻</em></p>
        </div>
    </div>
    <div id="the:main3" class="theorem">
        <p><strong>Теорема 4</strong>. <em>Построенные группы удовлетворяют
            условию <a href="#itm:condition3" data-reference-type="ref"
                       data-reference="itm:condition3">[3]</a>.</em></p>
        <div class="proof">
            <p><em><em>Proof.</em> Оценим количество тяжелых групп. Для этого
                рассмотрим, когда по построению мы должны закончить текущую тяжелую
                группу.</em></p>
            <ol>
                <li><p><em>Корень текущей тяжелой группы является корнем дерева. Так как
                    по теореме <a href="#the:main1" data-reference-type="ref"
                                  data-reference="the:main1">3</a> в каждую тяжелую вершину мы заходили
                    ровно <span class="math inline">1</span> раз, то так закончится не более
                    одной тяжелой группы.</em></p></li>
                <li><p><em>У родителя корня текущей тяжелой группы ровно <span
                        class="math inline">1</span> тяжелый сын (сам корень группы). Заметим,
                    что добавить родителя в группу мешают уже добавленные в группу тяжелые
                    вершины, кроме листа этой тяжелой группы, и легкие потомки родителя и
                    этих тяжелых вершин, которые не лежат в поддереве листа этой тяжелой
                    группы, а также сам родитель корня группы — именно эти вершины
                    составляют симметрическую разность поддеревьев листа тяжелой группы и
                    родителя текущей вершины. Каждая из этих вершин будет мешать нам не
                    более одного раза и для одного раза их должно быть не менее <span
                            class="math inline"><em>H</em></span>, следовательно не более <span
                            class="math inline">\(\frac{N}{H}\)</span> тяжелых групп может закончиться
                    таким образом.</em></p></li>
                <li><p><em>У родителя корня текущей тяжелой группы хотя бы <span
                        class="math inline">2</span> тяжелых сына. Рассмотрим тяжелую вершину, у
                    которой хотя бы <span class="math inline">2</span> тяжелых сына. Ее
                    сыновья относятся к разным группам, при этом рассматриваемая вершина по
                    построению не относится ни к одной из этих групп. Следовательно,
                    количество тяжелых групп, закончившихся рассматриваемым способом, равно
                    суммарному количеству тяжелых сыновей у вершин, у которых этих сыновей
                    больше <span class="math inline">1</span>. Чтобы найти это количество,
                    удалим из исходного дерева все легкие вершины вместе с инцидентными им
                    ребрами. Так как родитель тяжелой вершины сам является тяжелой вершиной,
                    то оставшийся граф будет деревом (или пустым графом, тогда в изначальном
                    дереве нет тяжелых вершин и по построению будет только одна группа —
                    легкая). Пусть количество вершин в нем <span
                            class="math inline"><em>c</em><em>n</em><em>t</em><sub><em>h</em></sub></span>.
                    Все листья этого дерева были тяжелыми вершинами в исходном дереве,
                    значит размеры их поддеревьев были не менее <span
                            class="math inline"><em>H</em></span>, при этом так как в новом дереве
                    они являются листьями, то в исходном дереве их поддеревья не
                    пересекались, следовательно количество таких вершин <span
                            class="math inline"><em>c</em><em>n</em><em>t</em><sub><em>l</em></sub></span>
                    не более <span class="math inline">\(\frac{N}{H}\)</span>. Ориентируем все
                    ребра полученного дерева от корня к листьям. Так как в новом дереве
                    <span
                            class="math inline"><em>c</em><em>n</em><em>t</em><sub><em>h</em></sub></span>
                    вершин, то в нем <span
                            class="math inline"><em>c</em><em>n</em><em>t</em><sub><em>h</em></sub> − 1</span>
                    ребер и суммарная исходящая степень всех вершин <span
                            class="math inline">(<em>c</em><em>n</em><em>t</em><sub><em>h</em></sub> − 1)</span>.
                    Пусть <span class="math inline"><em>S</em></span> — искомое количество
                    количество сыновей в новом дереве у вершин, у которых сыновей больше
                    <span class="math inline">1</span>, а количество таких вершин — <span
                            class="math inline"><em>k</em></span>, <span class="math inline">\(k \le
\frac{S}{2}\)</span>. А так как исходящая степень листа равна <span
                            class="math inline">0</span>, то суммарную исходящую степень всех вершин
                    можно представить следующим образом: <span
                            class="math display"><em>c</em><em>n</em><em>t</em><sub><em>h</em></sub> − 1 = <em>S</em> + (<em>c</em><em>n</em><em>t</em><sub><em>h</em></sub> − <em>c</em><em>n</em><em>t</em><sub><em>l</em></sub> − <em>k</em>) ⋅ 1</span>
                    <span
                            class="math display"><em>S</em> = <em>c</em><em>n</em><em>t</em><sub><em>l</em></sub> + <em>k</em> − 1,</span>
                    но так как <span class="math inline">\(k \le \frac{S}{2}\)</span>, то
                    <span class="math display">$$S \le cnt_l + \frac{S}{2} - 1$$</span>
                    <span
                            class="math display"><em>S</em> ≤ 2<em>c</em><em>n</em><em>t</em><sub><em>l</em></sub> − 1,</span>
                    но так как <span class="math inline">\(cnt_l \le \frac{N}{H}\)</span>, то
                    <span class="math display">$$S \le 2\frac{N}{H} - 1,$$</span> то есть
                    <span class="math inline">\(S = O(\frac{N}{H})\)</span>, а значит
                    количество тяжелых групп, заканчивающихся рассматриваемым образом равно
                    <span class="math inline">\(O(\frac{N}{H})\)</span>.</em></p></li>
            </ol>
            <p><em>Суммарно по всем случаям получаем <span
                    class="math inline">\(O(\frac{N}{H})\)</span> тяжелых групп, а так как
                легкая группа всего одна, то и общее количество построенных групп равно
                <span class="math inline">\(O(\frac{N}{H})\)</span>. ◻</em></p>
        </div>
    </div>
    <p>Перед построением разбиения вершин дерева на группы необходимо
        предпосчитать глубину и размер поддерева каждой вершины. Это можно
        сделать, например, с помощью обхода в глубину за <span
                class="math inline"><em>O</em>(<em>N</em>)</span>. При построении один
        раз использовалась сортировка подсчетом, запущенная на массиве из <span
                class="math inline"><em>N</em></span> элементов от <span
                class="math inline">0</span> до <span
                class="math inline">(<em>N</em> − 1)</span>. Таким образом, эта
        сортировка будет работать за <span
                class="math inline"><em>O</em>(<em>N</em>)</span>. При распределении
        тяжелых вершин по группам, каждая итерация цикла <code
                class="c">while</code> распределяла одну тяжелую вершину в группу,
        поэтому по теореме <a href="#the:main1" data-reference-type="ref"
                              data-reference="the:main1">3</a> этих итераций будет <span
                class="math inline"><em>O</em>(<em>N</em>)</span>. Таким образом, весь
        алгоритм разбиения вершин дерева на группы будет работать за <span
                class="math inline"><em>O</em>(<em>N</em>)</span>.</p>
    <h2 class="article_h2" id="решение-задач-с-помощью-описанного-представления">Решение задач
        с помощью описанного представления</h2>
    <h3 class="article_h3" id="запросы-на-поддеревьях">Запросы на поддеревьях</h3>
    <h4 class="article_h4" id="sec:base_problem">Количество различных элементов</h4>
    <p>Рассмотрим, как использовать разбиение на группы для ответов запросы
        к поддеревьям на примере количества различных элементов. Пусть дано
        корневое дерево из <span class="math inline"><em>N</em></span> вершин с
        корнем в вершине <span
                class="math inline"><em>r</em><em>o</em><em>o</em><em>t</em></span> и
        каждой вершине <span class="math inline"><em>v</em></span> приписано
        некоторое число <span
                class="math inline"><em>c</em><sub><em>v</em></sub></span>. Требуется
        обрабатывать запросы двух типов.</p>
    <ol>
        <li><p>Заменить значение, записанное в вершине <span
                class="math inline"><em>v</em></span>, на число <span
                class="math inline"><em>x</em></span>: <span
                class="math inline"><em>c</em><sub><em>v</em></sub> := <em>x</em></span>.</p></li>
        <li><p>Для поддерева вершины <span class="math inline"><em>v</em></span>
            найти количество различных чисел, записанных в вершинах этого
            поддерева.</p></li>
    </ol>
    <h3 class="article_h3" id="вспомогательная-структура-данных">Вспомогательная структура
        данных</h3>
    <p>Сначала научимся поддерживать вспомогательную структуру данных,
        которая позволит эффективно поддерживать мультимножество, отвечая на
        следующие запросы.</p>
    <ol>
        <li><p>Добавить элемент <span class="math inline"><em>x</em></span> в
            мультимножество.</p></li>
        <li><p>Удалить одно вхождение значения <span
                class="math inline"><em>x</em></span> из мультимножества.</p></li>
        <li><p>Узнать количество различных элементов в мультимножестве.</p></li>
    </ol>
    <p>Такая структура данных может быть реализована, например, с помощью
        хэш-таблицы, ключами в которой будут значения элементов, а значениями
        — количество раз, которое этот элемент входит в мультимножество. Кроме
        самой хэш-таблицы будем поддерживать количество различных элементов в
        мультимножестве в текущий момент.</p>
    <p>При добавлении элемента возможны 2 случая.</p>
    <ol>
        <li><p>Элемент уже присутствует в мультимножестве. В этом случае
            количество различных элементов не изменяется.</p></li>
        <li><p>Элемента еще нет в мультимножестве. В этом случае количество
            различных элементов увеличивается на <span
                    class="math inline">1</span>.</p></li>
    </ol>
    <p>Какой именно сейчас случай можно определить по хэш-таблице:</p>
    <pre><code class="language-cpp">class CountHashTable {
private:
    unordered_map&ltint, int> ht; // ключ - значение в вершине, значение - количество вершин с таким значением
    int distinct_count;         // количество различных значений в текущий момент времени
public:
    CountHashTable() : distinct_count(0) {};

    void add(int x);    // добавить элемент в структуру

    void del(int x);    // удалить элемент из структуры

    int get_distinct_count() {  // получить количество различных элементов в структуре
        return distinct_count;
    }
};

void CountHashTable::add(int x) {
    if(ht[x] == 0)
        distinct_count++;
    ht[x]++;
}</code></pre>
    <p>При удалении элемента возможны 2 аналогичных случая.</p>
    <ol>
        <li><p>Элемент присутствует в мультимножестве больше одного раза. В этом
            случае количество различных элементов не изменяется.</p></li>
        <li><p>Элемент присутствует в мультимножестве в единственном экземпляре.
            В этом случае количество различных элементов уменьшается на <span
                    class="math inline">1</span>.</p></li>
    </ol>
    <p>Реализация функции удаления одного вхождения элемента <span
            class="math inline"><em>x</em></span>:</p>
    <pre><code class="language-cpp">void CountHashTable::del(int x) {
    ht[x]--;
    if(ht[x] == 0) {
        distinct_count--;
        ht.erase(x);
    }
}</code></pre>
    <p>Теперь в любой момент времени в переменной <code
            class="c">distinct_count</code> хранится количество различных элементов
        в мультимножестве.</p>
    <p>Таким образом, данная структура данных позволяет отвечать на запросы
        за <span class="math inline"><em>O</em>(1)</span> времени и требует
        <span class="math inline"><em>O</em>(<em>n</em>)</span> памяти, где
        <span class="math inline"><em>n</em></span> — количество различных
        элементов в мультимножестве.</p>
    <h4 class="article_h4" id="использование-вспомогательной-структуры-данных">Использование
        вспомогательной структуры данных</h4>
    <p>Вернемся к изначальной задаче. Перед разделением на группы запустим
        из корня дерева обход в глубину, который посчитает размер поддеревьев,
        глубину вершин и построит Эйлеров обход, в который будем записывать
        вершину, только при первом входе в нее.</p>
    <pre><code class="language-cpp">vector&ltvector&ltint>> g;  // дерево в виде списка смежности
vector&ltint> d;// глубина вершины
vector&ltint> sz;     // размер поддеревьев
vector&ltint> tin;    // время входа в вершину
vector&ltint> tout;   // время выхода из вершины
vector&ltint> par;    // родитель вершины
vector&ltint> et;     // Эйлеров обход дерева

void dfs(int v, int depth) {
    tin[v] = int(et.size());
    et.push_back(v);
    d[v] = depth;

    sz[v] = 1;
    for(int u : g[v]) {
        if(u != par[v]) {
            par[u] = v;
            dfs(u, depth + 1);
            sz[v] += sz[u];
        }
    }

    tout[v] = int(et.size());
}</code></pre>
    <p>Здесь в двумерном массиве <code class="c">g</code> хранится исходное
        дерево в виде списка смежности, в <code class="c">sz[v]</code>  размер
        поддерева вершины <span class="math inline"><em>v</em></span>, в <code
                class="c">d[v]</code> — глубина вершины <span
                class="math inline"><em>v</em></span>, в массиве <code
                class="c">et</code> — Эйлеров обход дерева, а <code
                class="c">tin[v]</code> и <code class="c">tout[v]</code> показывают
        сколько вершин было в Эйлеровом обходе при входе в вершину <span
                class="math inline"><em>v</em></span> и при выходе из нее. При этом в
        полуинтервале Эйлерова обхода с позиции <span
                class="math inline"><em>t</em><em>i</em><em>n</em><sub><em>v</em></sub></span>
        до позиции <span
                class="math inline"><em>t</em><em>o</em><em>u</em><em>t</em><sub><em>v</em></sub></span>
        хранятся все вершины поддерева вершины <span
                class="math inline"><em>v</em></span> и только они.</p>
    <p>Для каждого листа <span class="math inline"><em>v</em></span> тяжелой
        группы построим описанную выше структуру данных и для каждой вершины
        <span class="math inline"><em>u</em> ∈ <em>T</em>(<em>v</em>)</span>
        добавим в эту структуру данных <span
                class="math inline"><em>c</em><sub><em>u</em></sub></span>. Это удобно
        сделать, используя построенный Эйлеров обход.</p>
    <pre><code class="language-cpp">vector&ltCountHashTable> cht(group_count);    // структуры данных для поддеревьев листов тяжелых групп
// перебираем тяжелую группу
for(int i = 1; i < group_count; i++) {
    // перебираем вершину в поддереве листа текущей тяжелой группы
    for(int j = tin[group_leaf[i]]; j < tout[group_leaf[i]]; j++) {
        cht[i].add(c[et[j]]);   // добавляем значение в этой вершине в соответствующую структуру данных
    }
}</code></pre>
    <p>В <code class="c">cht[0]</code> при этом хранится пустая структура
        данных, которая понадобится для работы с легкой группой.</p>
    <p>Теперь чтобы найти количество различных элементов в поддереве тяжелой
        вершины <span class="math inline"><em>v</em></span> нужно в структуру
        данных для листа <span
                class="math inline"><em>l</em><em>e</em><em>a</em><em>f</em></span>
        тяжелой группы, в которой находится вершина <span
                class="math inline"><em>v</em></span> добавить все вершины <span
                class="math inline"><em>u</em></span>, такие что <span
                class="math inline"><em>u</em> ∈ <em>T</em>(<em>v</em>)</span> и <span
                class="math inline"><em>u</em> ∉ <em>T</em>(<em>l</em><em>e</em><em>a</em><em>f</em>)</span>,
        ответить на запрос и удалить только что добавленные вершины, чтобы
        вернуть структуру данных в изначальное состояние. По свойству <a
                href="#itm:condition2" data-reference-type="ref"
                data-reference="itm:condition2">[2]</a> это займет <span
                class="math inline"><em>O</em>(<em>H</em>)</span> запросов к
        вспомогательной структуре данных, то есть <span
                class="math inline"><em>O</em>(<em>H</em>)</span> времени. Чтобы найти
        количество различных элементов в поддереве легкой вершины нужно добавить
        в пустую структуру данных все вершины из ее поддерева. По определению
        легкой вершины таких вершин <span
                class="math inline"><em>O</em>(<em>H</em>)</span>, следовательно ответ
        на запрос займет <span class="math inline"><em>O</em>(<em>H</em>)</span>
        времени.</p>
    <pre><code class="language-cpp">int distinct_query(int v) { // запрос количества различных в поддереве вершины v
    int res;    // переменная для результата
    if(sz[v] < H) { // если вершина v легкая
        for(int j = tin[v]; j < tout[v]; j++)
            cht[0].add(c[et[j]]);   // добавляем все вершины из поддерева v в пустую структуру данных

        res = cht[0].get_distinct_count();  // получаем ответ

        for(int j = tin[v]; j < tout[v]; j++)
            cht[0].del(c[et[j]]);   // очищаем структуру данных
    } else {    // если вершина v тяжелая
        int gr = group[v];  // определяем номер группы вершины v
        int leaf = group_leaf[gr];  // и лист этой тяжелой группы

        // добавляем в структуру данных листа все недостающие вершины
        for(int j = tin[v]; j < tin[leaf]; j++)
            cht[gr].add(c[et[j]]);
        for(int j = tout[leaf]; j < tout[v]; j++)
            cht[gr].add(c[et[j]]);

        // получаем ответ
        res = cht[gr].get_distinct_count();

        // возвращаем структуру данных в исходное состояние
        for(int j = tin[v]; j < tin[leaf]; j++)
            cht[gr].del(c[et[j]]);
        for(int j = tout[leaf]; j < tout[v]; j++)
            cht[gr].del(c[et[j]]);
    }

    return res; // возвращаем результат
}</code></pre>
    <p>Чтобы обрабатывать запрос изменения, нужно обновить все
        вспомогательные структуры данных. Для этого достаточно перебрать тяжелую
        группу и проверить, является ли лист этой тяжелой группы предком
        изменяемой вершины. Если является, то нужно обновить структуру данных
        для этого листа. Для этого достаточно удалить из нее старое значение в
        изменяемой вершине и добавить новое. Так как по условию <a
                href="#itm:condition3" data-reference-type="ref"
                data-reference="itm:condition3">[3]</a> групп всего <span
                class="math inline">\(O(\frac{N}{H})\)</span> и добавление и удаление
        работает за <span class="math inline"><em>O</em>(1)</span>, то общее
        время, требуемое для запроса изменения, равно <span
                class="math inline">\(O(\frac{N}{H})\)</span>.</p>
    <pre><code class="language-cpp">void update_query(int v, int new_val) { // запрос изменения значения в вершине v на new_val
    // перебираем тяжелую группу
    for(int i = 1; i &lt group_count; i++) {
        // проверяем, что изменяемая вершина лежит в поддереве листа этой тяжелой группы
        if(tin[group_leaf[i]] &lt= tin[v] && tout[v] &lt= tout[group_leaf[i]]) {
            // обновяем структуру данных для этого листа
            cht[i].del(c[v]);
            cht[i].add(new_val);
        }
    }

    // записываем новое значение в вершину
    c[v] = new_val;
}</code></pre>
    <p>Таким образом, предподсчет занимает <span
            class="math inline">\(O(\frac{N^2}{H})\)</span>(так как каждая из <span
            class="math inline"><em>N</em></span> вершин добавится в не более <span
            class="math inline">\(O(\frac{N}{H})\)</span> структур данных), для ответа
        на запрос изменения требуется <span
                class="math inline">\(O(\frac{N}{H})\)</span>, а на запрос количества
        различных элементов — <span
                class="math inline"><em>O</em>(<em>H</em>)</span> времени. Если принять
        <span class="math inline">\(H = \sqrt{N})\)</span>, то предподсчет займет
        <span class="math inline">\(O(N\sqrt{N})\)</span> времени и памяти, а для
        ответа на запрос любого типа потребуется <span
                class="math inline">\(O(\sqrt{N})\)</span> времени.</p>
    <p>Полный код реализации описанного решения можно найти в приложении <a
            href="#pril:A" data-reference-type="ref"
            data-reference="pril:A">[pril:A]</a></p>
    <p>Чтобы решить ту же задачу для других запросов достаточно поменять
        вспомогательную структуру данных.</p>
    <h4 class="article_h4" id="mode_ds">Мода</h4>
    <p>В качестве вспомогательной структуры данных для поддержки
        мультимножества и вычисления моды на нем, можно использовать следующую
        структуру данных: как и в случае с количеством различных элементов будем
        использовать хэш-таблицу, в которой ключом будет элемент множества, а
        значением — количество вхождений этого элемента в мультимножество.
        Помимо этого для каждого возможного количества <span
                class="math inline"><em>c</em><em>n</em><em>t</em></span> будем хранить
        двусвязный список элементов, которые встречаются мультимножестве в
        точности <span class="math inline"><em>c</em><em>n</em><em>t</em></span>
        раз, и максимальный индекс непустого двусвязного списка в этом массиве.
        Это число будет показывать, сколько раз мода встречается в
        мультимножестве.</p>
    <p>Теперь при добавлении (удалении) элемента соответствующий ему узел
        двусвязного списка удаляется из одного двусвязного списка и вставляется
        в другой с индексом на <span class="math inline">1</span> больше
        (меньше), максимальный индекс непустого двусвязного списка, который мы
        поддерживаем, изменится не более чем на <span
                class="math inline">1</span>.</p>
    <p>Чтобы найти моду достаточно взять произвольный элемент двусвязного
        списка, который находится в массиве в поддерживаемой позиции.</p>
    <p>Таким образом, каждый запрос обрабатывается за <span
            class="math inline"><em>O</em>(1)</span> времени.</p>
    <p>Полный код реализации описанной структуры данных можно найти в
        приложении <a href="#pril:B" data-reference-type="ref"
                      data-reference="pril:B">[pril:B]</a>.</p>
    <h4 class="article_h4" id="mex">MEX</h4>
    <p>Так как в самом большом поддереве <span
            class="math inline"><em>N</em></span> вершин, то нам требуется
        поддерживать мультимножество размера не более <span
                class="math inline"><em>N</em></span>, а MEX такого мультимножества не
        превосходит <span class="math inline"><em>N</em></span>, поэтому запросы
        добавления и удаления элементов, больших <span
                class="math inline"><em>N</em></span>, не повлияют на запросы нахождения
        MEX, поэтому можно обрабатывать запросы изменения только для чисел, не
        превосходящих <span class="math inline"><em>N</em></span>.</p>
    <p>Будем поддерживать массив натуральных чисел <span
            class="math inline"><em>c</em><em>n</em><em>t</em></span> размера <span
            class="math inline"><em>N</em> + 1</span>, в котором <span
            class="math inline"><em>c</em><em>n</em><em>t</em><sub><em>i</em></sub></span>
        будет обозначать количество раз, которое число <span
                class="math inline"><em>i</em></span> встречается в мультимножестве.
        Тогда MEX будет равен минимальному индексу <span
                class="math inline"><em>j</em></span>, такому что <span
                class="math inline"><em>c</em><em>n</em><em>t</em><sub><em>j</em></sub> = 0</span>,
        а запросы добавления и удаления элемента меняют один элемент этого
        массива на <span class="math inline">1</span>.</p>
    <p>Одним из способов эффективно обрабатывать такие запросы является
        корневая декомпозиция: разделим массив <span
                class="math inline"><em>c</em><em>n</em><em>t</em></span> на блоки
        размера <span class="math inline">\(B \approx \sqrt{N}\)</span>, для
        каждого блока будем хранить, сколько в нем нулевых элементов. Тогда
        изменение одного элемента меняет только сам элемент и изменяет не более
        чем на <span class="math inline">1</span> количество нулевых элементов в
        блоке, в котором произошло изменение. Чтобы найти MEX, нужно найти
        первый блок, в котором есть нулевой элемент и внутри этого блока найти
        первый такой элемент, его индекс будет результатом. Запрос изменения
        обрабатывается за <span class="math inline"><em>O</em>(1)</span>
        времени, а запрос нахождения MEX — за <span
                class="math inline">\(O(\frac{N}{B} + B) = O(\sqrt{N})\)</span> времени.
        Вся структура занимает <span
                class="math inline"><em>O</em>(<em>N</em>)</span> памяти.</p>
    <p>Если применить ее для решения изначальной задачи на поддеревьях, то
        обработка любого запроса все еще будет за <span
                class="math inline">\(O(\sqrt{N})\)</span> времени.</p>
    <h4 class="article_h4" id="поддеревья-некорневого-дерева">Поддеревья некорневого
        дерева</h4>
    <p>Рассмотрим задачу, аналогичную <a href="#sec:base_problem"
                                         data-reference-type="ref" data-reference="sec:base_problem">2.1.1</a>, с
        небольшим изменением: дерево не является корневым и в каждом запросе
        поиска какой-то информации про поддерево корень выбирается
        независимо.</p>
    <p>Для решения этой задачи заметим следующий факт: пусть для некоторого
        корня дерева <span
                class="math inline"><em>r</em><em>o</em><em>o</em><em>t</em></span>
        вершина <span class="math inline"><em>u</em></span> является сыном
        вершины <span class="math inline"><em>v</em></span>, то если перенести
        корень в поддерево вершины <span class="math inline"><em>u</em></span>,
        то поддеревом вершины <span class="math inline"><em>v</em></span> для
        нового корня будет наддерево вершины <span
                class="math inline"><em>u</em></span> для первоначального корня, то есть
        <span class="math inline">\(T(root) \diagdown T(u)$\)</span>, а если
        перенести корень дерева в вершину за пределами поддеревьев сыновей <span
                class="math inline"><em>v</em></span>, то поддерево вершины <span
                class="math inline"><em>v</em></span> для нового корня будет тем же, что
        и для первоначального корня. Таким образом, чтобы работать с
        поддеревьями в некорневом дереве достаточно научиться работать с
        поддеревьями и наддеревьями в корневом дереве.</p>
    <div class="lemma">
        <p><strong>Лемма 5</strong>. <em>Симметрическая разность наддеревьев
            двух вершин одной группы состоит из <span
                    class="math inline"><em>O</em>(<em>H</em>)</span> элементов.</em></p>
        <div class="proof">
            <p><em><em>Proof.</em> Пусть вершины <span
                    class="math inline"><em>v</em></span> и <span
                    class="math inline"><em>u</em></span> принадлежат одной группе. Тогда
                <span class="math display">$$|(T(root) \diagdown T(v)) \triangle
(T(root) \diagdown T(u))| = |T(v) \triangle T(u)|,$$</span> что по
                условию <a href="#itm:condition2" data-reference-type="ref"
                           data-reference="itm:condition2">[2]</a> равно <span
                        class="math inline"><em>O</em>(<em>H</em>)</span>. ◻</em></p>
        </div>
    </div>
    <p>Теперь задачу для наддеревьев можно решать аналогично задаче для
        поддеревьев: для каждого листа тяжелой группы строим структуру данных из
        всех вершин в наддереве этого листа и используем эту структуру данных
        для ответа на запросы ко всем вершинам из этой тяжелой группы; для
        легкой группы решение будет отличаться несколько больше: построим
        структуру данных из всех вершин в дереве и для ответа на запрос о
        наддереве легкой вершины удалим из этой структуры данных все вершины в
        поддереве этой вершины. Эту структуру данных при запросах изменения
        нужно будет обновлять также как структуры данных для листьев тяжелых
        групп.</p>
    <h4 class="article_h4" id="добавление-листа">Добавление листа</h4>
    <p>Вернемся к изначальной задаче, но теперь будем также обрабатывать
        запросы добавления листа в дерево. То есть теперь задача имеет следующий
        вид: Пусть дано корневое дерево из <span
                class="math inline"><em>N</em></span> вершин с корнем в вершине <span
                class="math inline"><em>r</em><em>o</em><em>o</em><em>t</em></span> и
        каждой вершине <span class="math inline"><em>v</em></span> приписано
        некоторое число <span
                class="math inline"><em>c</em><sub><em>v</em></sub></span>. Требуется
        обрабатывать запросы трех типов.</p>
    <ol>
        <li><p>Заменить значение записанное в вершине <span
                class="math inline"><em>v</em></span> на число <span
                class="math inline"><em>x</em></span>: <span
                class="math inline"><em>c</em><sub><em>v</em></sub> := <em>x</em></span>.</p></li>
        <li><p>Для поддерева вершины <span class="math inline"><em>v</em></span>
            найти количество различных чисел, записанных в вершинах этого
            поддерева.</p></li>
        <li><p>Подвесить к вершине <span class="math inline"><em>v</em></span>
            лист с номером <span class="math inline"><em>u</em></span> и значением
            <span class="math inline"><em>c</em><sub><em>u</em></sub></span>,
            записанным в нем.</p></li>
    </ol>
    <p>Пусть нужно обработать не более <span
            class="math inline"><em>H</em></span> запросов. Тогда также как и в
        изначальной задаче разделим вершины на группы и для поддеревьев каждого
        листа тяжелой группы построим вспомогательную структуру данных. Запросы
        первых двух типов будем обрабатывать аналогично предыдущим решениям.
        Рассмотрим, что происходит при добавлении листа <span
                class="math inline"><em>u</em></span> в дерево. Чтобы построенные
        вспомогательные структуры данных были актуальны после этого добавления
        вставим <span class="math inline"><em>c</em><sub><em>u</em></sub></span>
        во все вспомогательные структуры данных для листов тяжелых групп,
        которые являются предками добавленного листа. Так как всего тяжелых
        групп <span class="math inline">\(O(\frac{N}{H})\)</span>, то добавление
        листа будет работать за <span
                class="math inline">\(O(\frac{N}{H})\)</span>. Заметим, что так как
        запросов не более <span class="math inline"><em>H</em></span>, то в
        дерево добавится не более <span class="math inline"><em>H</em></span>
        новых вершин, поэтому условие <a href="#itm:condition2"
                                         data-reference-type="ref"
                                         data-reference="itm:condition2">[2]</a> все еще будет
        соблюдаться, поэтому асимптотика времени обработки запросов останется
        той же — <span class="math inline"><em>O</em>(<em>H</em>)</span>, <span
                class="math inline">\(O(\frac{N}{H})\)</span> и <span
                class="math inline">\(O(\frac{N}{H})\)</span> для первого, второго и
        третьего типов запросов соответственно.</p>
    <p>Теперь пусть требуется обработать <span
            class="math inline"><em>Q</em></span> запросов. Разделим все запросы на
        блоки по <span class="math inline"><em>H</em></span> запросов (возможно
        последний блок будет неполным). Перед обработкой каждого блока запросов
        перестроим группы и вспомогательные структуры данных. Это займет <span
                class="math inline">\(O(\frac{N^2}{H})\)</span> времени. Тогда суммарное
        время работы будет <span class="math inline">\(O(\frac{Q}{H} \cdot (S +
\frac{S^2}{H}) + Q(H + \frac{S}{H}))\)</span>, где <span
                class="math inline"><em>S</em> = <em>O</em>(<em>N</em> + <em>Q</em>)</span>
        — количество вершин в дереве после всех запросов, <span
                class="math inline">\(O(\frac{Q}{H})\)</span> — количество блоков, <span
                class="math inline"><em>O</em>(<em>S</em>)</span> — время построения
        разбиения на группы, <span class="math inline">\(O(\frac{S^2}{H})\)</span>
        — время построения вспомогательных структур данных в начале каждого
        блока, <span class="math inline">\(O(H + \frac{S}{H})\)</span> — время
        обработки одного запроса произвольного типа.</p>
    <p>Это решение можно оптимизировать. Для этого не будем перестраивать
        все вспомогательные структуры данных с нуля в начале каждого блока.
        Сделаем так только для первого блока, а для всех последующих будем
        использовать вспомогательные структуры данных построенные для
        предыдущего блока. Для этого построим разбиение на группы для текущего
        блока запросов, сохранив предыдущее разбиение. Рассмотрим тяжелую группу
        из нового разбиения. Требуется построить вспомогательную структуру
        данных для поддерева листа <span class="math inline"><em>v</em></span>
        этой тяжелой вершины. Если в этой группе есть лист <span
                class="math inline"><em>u</em></span> тяжелой группы из прошлого
        разбиения, то удалим из вспомогательной структуры данных для поддерева
        вершины <span class="math inline"><em>u</em></span> все вершины, которые
        входят в поддерево вершины <span class="math inline"><em>u</em></span>,
        но не входят в поддерево вершины <span
                class="math inline"><em>v</em></span>. Теперь эта структура данных
        соответствует поддереву <span
                class="math inline"><em>T</em>(<em>v</em>)</span>. Если в этой тяжелой
        группе нет листа тяжелой группы из прошлого разбиения, то построим
        вспомогательную структуру данных для <span
                class="math inline"><em>T</em>(<em>v</em>)</span> наивным образом.</p>
    <div class="lemma">
        <p><strong>Лемма 6</strong>. <em>После добавления некоторого, возможно
            нулевого, числа листьев в дерево в новом разбиении на группы в одной
            тяжелой группе не могут находиться два листа тяжелых групп прошлого
            разбиения на группы.</em></p>
        <div class="proof">
            <p><em><em>Proof.</em> Докажем утверждение леммы от противного. Пусть
                вершины <span class="math inline"><em>v</em></span> и <span
                        class="math inline"><em>u</em></span> были листами тяжелых групп
                прошлого разбиения попали в одну тяжелую группу в новом разбиении и
                пусть <span
                        class="math inline"><em>d</em>(<em>u</em>) &lt; <em>d</em>(<em>v</em>)</span>.
                Так как при построении предыдущего разбиения вершина <span
                        class="math inline"><em>v</em></span> не попала в тяжелую группу с
                листом <span class="math inline"><em>u</em></span>, то <span
                        class="math inline">|<em>T</em><sub>0</sub>(<em>v</em>)△<em>T</em><sub>0</sub>(<em>u</em>)| &gt; <em>H</em></span>,
                где <span class="math inline"><em>T</em><sub>0</sub>(<em>v</em>)</span>
                — поддерево вершины <span class="math inline"><em>v</em></span> до
                добавления новых листов. Следовательно, так как при добавлении листа в
                дерево симметрическая разность двух поддеревьев не могла уменьшиться, то
                для тяжелой группы из нового разбиения, в которую по предположению
                попали вершины <span class="math inline"><em>v</em></span> и <span
                        class="math inline"><em>u</em></span>, нарушается условие <a
                        href="#itm:condition2" data-reference-type="ref"
                        data-reference="itm:condition2">[2]</a> —
                противоречие ◻</em></p>
        </div>
    </div>
    <p>Это также означает, что количество тяжелых групп не уменьшается при
        переходе к следующему блоку запросов.</p>
    <p>Таким образом, пусть в разбиении для предыдущего блока запросов было
        <span class="math inline"><em>x</em></span> тяжелых групп, а для нового
        блока — <span class="math inline"><em>y</em></span> тяжелых запросов
        (<span class="math inline"><em>x</em> ≤ <em>y</em></span>), наивным
        образом будет построено <span
                class="math inline"><em>y</em> − <em>x</em></span> вспомогательных
        структур данных. Но после всех запросов по условию <a
                href="#itm:two_subtrees_case_3" data-reference-type="ref"
                data-reference="itm:two_subtrees_case_3">[3]</a>
        будет <span class="math inline">\(\frac{S}{H}\)</span> тяжелых групп,
        следовательно, наивным образом за <span
                class="math inline"><em>O</em>(<em>S</em>)</span> будет построено только
        <span class="math inline">\(\frac{S}{H}\)</span> вспомогательных структур
        данных. Поэтому общее время работы такого решения будет <span
                class="math inline">\(O(\frac{Q}{H} \cdot S + \frac{S^2}{H} + Q(H +
\frac{S}{H})) = O(\frac{S^2}{H} + QH + \frac{QS}{H}) = O(\frac{S^2}{H} +
QH)\)</span>. При <span class="math inline">\(H \approx
\sqrt{\frac{S^2}{Q}}\)</span> получим <span
                class="math inline">\(O(S\sqrt{Q}) = O((N + Q)\sqrt{Q})\)</span>
        времени.</p>
    <h3 class="article_h3" id="другие-подмножества-вершин-дерева">Другие подмножества вершин
        дерева</h3>
    <p>Решим похожую задачу для более специфических множеств вершин
        дерева.</p>
    <h4 class="article_h4" id="объединение-поддерева-и-пути">Объединение поддерева и пути</h4>
    <p>Пусть дано корневое дерево из <span
            class="math inline"><em>N</em></span> вершин с корнем в вершине <span
            class="math inline"><em>r</em><em>o</em><em>o</em><em>t</em></span>. В
        каждой вершине <span class="math inline"><em>v</em></span> записано
        некоторое число <span
                class="math inline"><em>c</em><sub><em>v</em></sub></span>. Требуется
        для <span class="math inline"><em>q</em></span> подмножеств вершин,
        каждое из которых задается двумя вершинами <span
                class="math inline"><em>v</em></span> и <span
                class="math inline"><em>u</em></span> и представляет собой объединение
        поддерева вершины <span class="math inline"><em>v</em></span> и вершин
        на кратчайшем пути между <span class="math inline"><em>v</em></span> и
        <span class="math inline"><em>u</em></span>, посчитать сколько различных
        чисел записано в вершинах этого подмножества.</p>
    <p>По сути одно подмножество представляет собой запрос и все запросы
        будут обрабатываться в режиме offline.</p>
    <p>Возможны вариации этой задачи в зависимости от того, может ли вершина
        <span class="math inline"><em>u</em></span> лежать в поддереве вершины
        <span class="math inline"><em>v</em></span>, если да, то будут ли
        вершины, которые лежат и на пути, и в поддереве считаться только один
        раз или два раза. Все они практически не отличаются в реализации, далее
        будем считать, что вершина <span class="math inline"><em>u</em></span>
        не лежит в поддереве вершины <span
                class="math inline"><em>v</em></span>: <span
                class="math inline"><em>u</em> ∉ <em>T</em>(<em>v</em>)</span>. Кроме
        того, вместо количества различных элементов могут быть и другие запросы
        — в решении поменяется только используемая вспомогательная структура
        данных.</p>
    <p>Для решения задачи построим Эйлеров обход дерева, в котором будем
        добавлять вершину в обход, когда заходим в нее в первый раз, каждый раз,
        когда возвращаемся в нее и при выходе. Обозначим количество раз, которое
        вершина <span class="math inline"><em>v</em></span> встречается в этом
        Эйлеровом обходе <span
                class="math inline"><em>c</em><em>n</em><em>t</em><sub><em>v</em></sub></span>,
        индекс первого вхождения вершины <span
                class="math inline"><em>v</em></span> в Эйлеров обход <span
                class="math inline"><em>t</em><em>i</em><em>n</em><sub><em>v</em></sub></span>,
        а индекс последнего вхождения <span
                class="math inline"><em>t</em><em>o</em><em>u</em><em>t</em><sub><em>v</em></sub></span>.</p>
    <p>Рассмотрим поддерево произвольной вершины <span
            class="math inline"><em>v</em></span>, <span
            class="math inline"><em>T</em>(<em>v</em>)</span>. Поставим ему в
        соответствие отрезок Эйлерова обхода с индекса <span
                class="math inline"><em>t</em><em>i</em><em>n</em><sub><em>v</em></sub></span>
        до <span
                class="math inline"><em>t</em><em>o</em><em>u</em><em>t</em><sub><em>v</em></sub></span>
        включительно. По свойствам Эйлерова обхода все вершины, которые
        встречаются в этом отрезке, и только они принадлежат <span
                class="math inline"><em>T</em>(<em>v</em>)</span>.</p>
    <p>Рассмотрим кратчайший путь между вершинами <span
            class="math inline"><em>v</em></span> и <span
            class="math inline"><em>u</em></span>. Поставим ему в соответствие
        отрезок Эйлерова обхода с концами <span
                class="math inline"><em>t</em><em>i</em><em>n</em><sub><em>v</em></sub></span>
        и <span
                class="math inline"><em>t</em><em>i</em><em>n</em><sub><em>u</em></sub></span>,
        если вершины <span class="math inline"><em>v</em></span> и <span
                class="math inline"><em>u</em></span> являются парой предок-потомок,
        иначе — отрезок с концами <span
                class="math inline"><em>t</em><em>o</em><em>u</em><em>t</em><sub><em>v</em></sub></span>
        и <span
                class="math inline"><em>t</em><em>i</em><em>n</em><sub><em>u</em></sub></span>,
        если <span
                class="math inline"><em>t</em><em>i</em><em>n</em><sub><em>v</em></sub> &lt; <em>t</em><em>i</em><em>n</em><sub><em>u</em></sub></span>,
        или <span
                class="math inline"><em>t</em><em>o</em><em>u</em><em>t</em><sub><em>u</em></sub></span>
        и <span
                class="math inline"><em>t</em><em>i</em><em>n</em><sub><em>v</em></sub></span>,
        если <span
                class="math inline"><em>t</em><em>i</em><em>n</em><sub><em>v</em></sub> &gt; <em>t</em><em>i</em><em>n</em><sub><em>u</em></sub></span>.
        По свойствам Эйлерова обхода все вершины <span
                class="math inline"><em>w</em></span>, которые встречаются в этом
        отрезке хотя бы один раз, но меньше <span
                class="math inline"><em>c</em><em>n</em><em>t</em><sub><em>w</em></sub></span>,
        и только они принадлежат этому пути.</p>
    <p>Теперь описанные в условии множества можно представить в виде
        упорядоченной пары отрезков Эйлерова обхода, у которых совпадает один
        конец. Для определенности будем считать, что начало отрезка,
        соответствующего пути, будет совпадать с концом отрезка,
        соответствующего поддереву. Второй случай решается аналогично.</p>
    <p>Пусть мы построили вспомогательную структуру данных для вершин одного
        заданного подмножества вершин и получили для этого подмножества ответ.
        Давайте перестроим эту вспомогательную структуру данных для другого
        заданного подмножества. Пусть пара отрезков Эйлерова обхода для текущего
        подмножества была <span
                class="math inline">[<em>l</em><em>f</em><sub><em>t</em></sub>, <em>r</em><em>g</em><sub><em>t</em></sub>]</span>
        — для поддерева, <span
                class="math inline">[<em>l</em><em>f</em><sub><em>p</em></sub>, <em>r</em><em>g</em><sub><em>p</em></sub>]</span>
        — для пути (<span
                class="math inline"><em>r</em><em>g</em><sub><em>t</em></sub> = <em>l</em><em>f</em><sub><em>p</em></sub></span>).
        Будем двигать границы этих отрезков поддерживая соответствующие им
        поддерево и путь. Для этого для каждого из двух отрезков будем хранить,
        сколько раз каждая из вершин встречается на этом отрезке. При движении
        границы отрезка на <span class="math inline">1</span> в него
        добавилась/удалилась одна вершина <span
                class="math inline"><em>w</em></span>, обновим количество раз, которое
        встречается <span class="math inline"><em>w</em></span> в отрезке и в
        зависимости от того, как изменилось это количество добавим или удалим
        <span class="math inline"><em>c</em><sub><em>w</em></sub></span> из
        вспомогательной структуры данных или ничего не сделаем.</p>
    <p>Таким образом, можно перестраивать вспомогательную структуру данных
        для другого подмножества и, используя ее, искать в этом подмножестве
        количество различных элементов. Но из-за того, что при переходе от
        одного подмножества к другому нет никаких ограничений на взаимное
        расположений старых отрезков и новых, переход будет обрабатываться за
        <span class="math inline"><em>O</em>(<em>N</em>)</span>, что суммарно по
        всем запросам даст <span
                class="math inline"><em>O</em>(<em>N</em><em>q</em>)</span>. Вместо
        того, что бы отвечать на запросы в заданном порядке, давайте отсортируем
        эти запросы. Разделим все вершины на блоки. Номером блока тяжелой
        вершины будет номер ее тяжелой группы, а номером блока легкой вершины
        <span class="math inline"><em>v</em></span> будет число <span
                class="math inline">\(\lfloor \frac{tin_v}{H} \rfloor\)</span>.
        Отсортируем все запросы по номерам блока вершин <span
                class="math inline"><em>v</em></span>, а при равенстве номеров блоков —
        по числам <span
                class="math inline"><em>r</em><em>g</em><sub><em>p</em></sub></span>.</p>
    <div id="the:subtree_and_path" class="theorem">
        <p><strong>Теорема 7</strong>. <em>Если рассматривать запросы в
            указанном порядке, общее количество движений границ двух рассматриваемых
            отрезков будет <span class="math inline">\(O(qH +
\frac{N^2}{H})\)</span>.</em></p>
        <div class="proof">
            <p><em><em>Proof.</em> Количество блоков запросов равно сумме количества
                тяжелых групп (их по условию <a href="#itm:condition3"
                                                data-reference-type="ref"
                                                data-reference="itm:condition3">[3]</a> <span
                        class="math inline">\(O(\frac{N}{H})\)</span>) и количеству различных
                значений выражения <span class="math inline">\(\lfloor \frac{tin_v}{H}
\rfloor\)</span>, в котором <span
                        class="math inline"><em>t</em><em>i</em><em>n</em><sub><em>v</em></sub></span>
                может принимать целые значения от <span class="math inline">0</span> до
                <span class="math inline"><em>N</em> − 1</span> включительно, значит,
                количество различных значений этого выражения равно <span
                        class="math inline">\(O(\frac{N}{H})\)</span>, то есть всего блоков
                запросов <span class="math inline">\(O(\frac{N}{H})\)</span>.</em></p>
            <p><em>Рассмотрим отдельно переходы между запросами внутри одного блока
                и между разными блоками.</em></p>
            <p><em>Если два запроса принадлежат одному блоку, то соответствующие им
                вершины <span class="math inline"><em>v</em></span> лежат в одной
                группе, следовательно, суммарная разница между границами отрезков
                отвечающих за поддеревья между запросами одного блока будет <span
                        class="math inline"><em>O</em>(<em>H</em>)</span>. Так как левая граница
                отрезка пути совпадает с правой границей отрезка поддерева, то она тоже
                изменится на <span class="math inline"><em>O</em>(<em>H</em>)</span>.
                Осталось посчитать изменения правой границы отрезка пути <span
                        class="math inline"><em>r</em><em>g</em><sub><em>p</em></sub></span>.
                Так как внутри одного блока запросов запросы отсортированы по правой
                границе отрезка пути, то при обработке всех запросов одного блока эта
                граница сдвинется не более чем на <span
                        class="math inline"><em>N</em></span> единиц.</em></p>
            <p><em>Так как всего блоков <span
                    class="math inline">\(O(\frac{N}{H})\)</span> и запросы отсортированы в
                первую очередь по номерам блоков, то всего пар соседних запросов из
                разных блоков будет <span class="math inline">\(O(\frac{N}{H})\)</span>.
                Переход от одного запроса такой пары к другому будет обрабатываться за
                <span class="math inline"><em>O</em>(<em>N</em>)</span> движений границ
                отрезков.</em></p>
            <p><em>Суммарно получаем <span class="math inline">\(O(qH) + O(qH) +
O(N\frac{N}{H}) + O(N\frac{N}{H}) = O(qH + \frac{N^2}{H})\)</span>. Здесь
                первое слагаемое отвечает за переходы между отрезками поддеревьев
                запросов одного блока, второе слагаемое — за суммарное движение левой
                границы отрезка пути между запросами одного блока, третье слагаемое —
                за суммарное движение правой границы отрезка пути между запросами одного
                блока, четвертое слагаемое — за движение обоих отрезков между запросами
                разных блоков. ◻</em></p>
        </div>
    </div>
    <p>Принимая <span class="math inline">\(H \approx
\frac{N}{\sqrt{q}}\)</span>, получаем суммарное количество движений
        границ отрезков будет равно <span
                class="math inline">\(O(N\sqrt{q})\)</span>, а так как движение одной
        границы на <span class="math inline">1</span> обрабатывается за <span
                class="math inline"><em>O</em>(1)</span> и получение ответа на запрос во
        вспомогательной структуре данных работает также за <span
                class="math inline"><em>O</em>(1)</span>, то суммарное время работы
        будет <span class="math inline">\(O(N\sqrt{q})\)</span>.</p>
    <h4 class="article_h4" id="объединение-двух-поддеревьев">Объединение двух поддеревьев</h4>
    <p>Пусть дано корневое дерево из <span
            class="math inline"><em>N</em></span> вершин с корнем в вершине <span
            class="math inline"><em>r</em><em>o</em><em>o</em><em>t</em></span>. В
        каждой вершине <span class="math inline"><em>v</em></span> записано
        некоторое число <span
                class="math inline"><em>c</em><sub><em>v</em></sub></span>. Требуется
        для <span class="math inline"><em>q</em></span> подмножеств вершин,
        каждое из которых задается двумя вершинами <span
                class="math inline"><em>v</em></span> и <span
                class="math inline"><em>u</em></span> и представляет собой объединение
        поддеревьев вершин <span class="math inline"><em>v</em></span> и <span
                class="math inline"><em>u</em></span>, посчитать сколько различных чисел
        записано в вершинах этого подмножества.</p>
    <p>Построим на данном дереве Heavy-Light декомпозицию. Пусть вершина
        <span class="math inline"><em>w</em></span> попала на путь Heavy-Light
        декомпозиции(далее hld-путь) под номером <span
                class="math inline"><em>p</em><em>a</em><em>t</em><em>h</em><sub><em>w</em></sub></span>
        и занимает в нем позицию <span
                class="math inline"><em>p</em><em>o</em><em>s</em><sub><em>w</em></sub></span>,
        считая от самой нижней вершины этого hld-пути.</p>
    <p>Разделим запросы на блоки в зависимости от того, в какую группу
        попала вершина <span class="math inline"><em>v</em></span> каждого
        запроса. Для каждого блока будем решать задачу независимо. Внутри одного
        блока разделим запросы на подблоки в зависимости от hld-пути, на
        котором лежат вершины <span class="math inline"><em>u</em></span> этих
        запросов.</p>
    <p>Отсортируем запросы в первую очередь по номерам блоков, во вторую —
        по номерам подблоков, а в третью — в порядке неубывания величин <span
                class="math inline"><em>p</em><em>o</em><em>s</em><sub><em>u</em></sub></span>.</p>
    <p>Пусть мы имеем вспомогательную структуру данных построенную на
        объединении двух поддеревьев для одного запроса (обозначим корни
        поддеревьев этого запроса <span
                class="math inline"><em>v</em><sub>1</sub></span> и <span
                class="math inline"><em>u</em><sub>1</sub></span>). Перестроим ее для
        объединения двух поддеревьев следующего запроса (обозначим корни
        поддеревьев этого запроса <span
                class="math inline"><em>v</em><sub>2</sub></span> и <span
                class="math inline"><em>u</em><sub>2</sub></span>). Для этого рассмотрим
        несколько случаев.</p>
    <ol>
        <li><p><span id="itm:two_subtrees_case_1"
                     label="itm:two_subtrees_case_1"></span> Следующий запрос лежит в другом
            блоке запросов. В этом случае очищаем всю вспомогательную структуру
            данных и заполняем ее всеми искомыми вершинами следующего
            запроса.</p></li>
        <li><p><span id="itm:two_subtrees_case_2"
                     label="itm:two_subtrees_case_2"></span> Следующий запрос лежит в другом
            подблоке запросов. В этом случае удаляем из вспомогательной структуры
            данных все вершины, принадлежащие <span
                    class="math inline"><em>T</em>(<em>u</em><sub>1</sub>)</span>, добавляем
            все вершины, принадлежащие <span
                    class="math inline"><em>T</em>(<em>u</em><sub>2</sub>)</span>,
            исправляем разницу между поддеревьями вершин <span
                    class="math inline"><em>v</em><sub>1</sub></span> и <span
                    class="math inline"><em>v</em><sub>2</sub></span> аналогично <a
                    href="#sec:base_problem" data-reference-type="ref"
                    data-reference="sec:base_problem">2.1.1</a>.</p></li>
        <li><p><span id="itm:two_subtrees_case_3"
                     label="itm:two_subtrees_case_3"></span> Следующий запрос лежит в том же
            подблоке. Так как <span
                    class="math inline"><em>u</em><sub>1</sub></span> и <span
                    class="math inline"><em>u</em><sub>2</sub></span> лежат на одном
            hld-пути и по условию сортировки <span
                    class="math inline"><em>u</em><sub>1</sub></span> глубже <span
                    class="math inline"><em>u</em><sub>2</sub></span>, то <span
                    class="math inline"><em>u</em><sub>2</sub></span> является предком <span
                    class="math inline"><em>u</em><sub>1</sub></span>, поэтому <span
                    class="math inline"><em>T</em>(<em>u</em><sub>1</sub>) ⊂ <em>T</em>(<em>u</em><sub>2</sub>)</span>.
            Добавим во вспомогательную структуру данных все вершины, принадлежащие
            <span class="math inline">\(T(u_2) \diagdown T(u_1)\)</span>, и исправляем
            разницу между поддеревьями вершин <span
                    class="math inline"><em>v</em><sub>1</sub></span> и <span
                    class="math inline"><em>v</em><sub>2</sub></span> аналогично <a
                    href="#sec:base_problem" data-reference-type="ref"
                    data-reference="sec:base_problem">2.1.1</a>.</p></li>
    </ol>
    <div class="theorem">
        <p><strong>Теорема 8</strong>. <em>При обработке запросов указанным выше
            образом будет совершено <span class="math inline">\(O(qH + \frac{N^2
\log{N}}{H})\)</span> запросов к вспомогательной структуре
            данных.</em></p>
        <div class="proof">
            <p><em><em>Proof.</em> Переход типа <a href="#itm:two_subtrees_case_1"
                                                   data-reference-type="ref"
                                                   data-reference="itm:two_subtrees_case_1">[1]</a>
                будет использовать <span
                        class="math inline">|<em>T</em>(<em>v</em><sub>1</sub>)| + |<em>T</em>(<em>u</em><sub>1</sub>)| + |<em>T</em>(<em>v</em><sub>2</sub>)| + |<em>T</em>(<em>u</em><sub>2</sub>)| = <em>O</em>(<em>N</em>)</span>
                запросов к вспомогательной структуре данных. Так как всего блоков
                запросов столько же, сколько существует групп, то есть <span
                        class="math inline">\(O(\frac{N}{H})\)</span>, то суммарно все такие
                переходы будут работать за <span
                        class="math inline">\(O(\frac{N^2}{H})\)</span> запросов к вспомогательной
                структуре данных.</em></p>
            <p><em>Переходы типов <a href="#itm:two_subtrees_case_2"
                                     data-reference-type="ref"
                                     data-reference="itm:two_subtrees_case_2">[2]</a>
                и <a href="#itm:two_subtrees_case_3" data-reference-type="ref"
                     data-reference="itm:two_subtrees_case_3">[3]</a>
                разделим на две части: работа с поддеревьями вершин <span
                        class="math inline"><em>v</em></span> и вершин <span
                        class="math inline"><em>u</em></span>. Переход между поддеревьями <span
                        class="math inline"><em>v</em><sub>1</sub></span> и <span
                        class="math inline"><em>v</em><sub>2</sub></span> в обоих случаях
                работает одинаково за <span
                        class="math inline">|<em>T</em>(<em>v</em><sub>1</sub>)△<em>T</em>(<em>v</em><sub>2</sub>)|</span>
                запросов к вспомогательной структуре данных, что по условию <a
                        href="#itm:condition2" data-reference-type="ref"
                        data-reference="itm:condition2">[2]</a> равно <span
                        class="math inline"><em>O</em>(<em>H</em>)</span>. Так как всего
                запросов <span class="math inline"><em>q</em></span>, то эта часть
                совершает <span
                        class="math inline"><em>O</em>(<em>q</em><em>H</em>)</span> запросов к
                вспомогательной структуре данных.</em></p>
            <p><em>Для оценки второй части рассмотрим произвольную вершину <span
                    class="math inline"><em>w</em></span>. Она лежит в поддеревьях <span
                    class="math inline"><em>O</em>(log <em>N</em>)</span> hld-путей,
                поэтому внутри одного блока запросов она будет добавлена и удалена всего
                <span class="math inline"><em>O</em>(log <em>N</em>)</span> раз. Так как
                всего вершин <span class="math inline"><em>N</em></span>, а блоков
                запросов <span class="math inline">\(O(\frac{N}{H})\)</span>, то эта часть
                работает за <span class="math inline">\(O(\frac{N^2
\log{N}}{H})\)</span>.</em></p>
            <p><em>Суммарно по всем случаям получаем <span class="math inline">\(O(qH
+ \frac{N^2 \log{N}}{H})\)</span> запросов к вспомогательной структуре
                данных. ◻</em></p>
        </div>
    </div>
    <p>Принимая <span class="math inline">\(H \approx N
\sqrt{\frac{\log{N}}{q}}\)</span>, получаем <span
            class="math inline">\(O(N\sqrt{q\log{N}})\)</span> запросов к
        вспомогательной структуре данных.</p>

    <h2 id="pril:A" class="article_h2">Приложение А. Количество различных элементов в поддереве</h2>
    <pre><code class="language-cpp">#include &ltiostream>
#include &ltvector>
#include &ltunordered_map>
#include &ltmath.h>

using namespace std;

class CountHashTable {
private:
    unordered_map&ltint, int> ht; // ключ - значение в вершине, значение - количество вершин с таким значением
    int distinct_count;         // количество различных значений в текущий момент времени
public:
    CountHashTable() : distinct_count(0) {};

    void add(int x);    // добавить элемент в структуру

    void del(int x);    // удалить элемент из структуры

    int get_distinct_count() {  // получить количество различных элеиентов в структуре
        return distinct_count;
    }
};

void CountHashTable::add(int x) {
    if(ht[x] == 0)
        distinct_count++;
    ht[x]++;
}

void CountHashTable::del(int x) {
    ht[x]--;
    if(ht[x] == 0) {
        distinct_count--;
        ht.erase(x);
    }
}

int H;
vector&ltint> c;          // значения, записанные в вершинах
vector&ltvector&ltint>> g;  // дерево в виде списка смежности
vector&ltint> d;// глубина вершины
vector&ltint> sz;     // размер поддеревьев
vector&ltint> tin;    // время входа в вершину
vector&ltint> tout;   // время выхода из вершины
vector&ltint> par;    // родитель вершины
vector&ltint> et;     // Эйлеров обход дерева
int group_count;    // количество групп
vector&ltint> group;  // номер группы
vector&ltint> group_leaf;  // лист тяжелой группы
vector&ltint> group_root;  // корень тяжелой группы
vector&ltCountHashTable> cht; // структуры данных в листах тяжелых вершин

void dfs(int v, int depth) {
    tin[v] = int(et.size());
    et.push_back(v);
    d[v] = depth;

    sz[v] = 1;
    for(int u : g[v]) {
        if(u != par[v]) {
            par[u] = v;
            dfs(u, depth + 1);
            sz[v] += sz[u];
        }
    }

    tout[v] = int(et.size());
}

void update_query(int v, int new_val) { // запрос изменения значения в вершине v на new_val
    // перебираем тяжелую группу
    for(int i = 1; i < group_count; i++) {
        // проверяем, что изменяемая вершина лежит в поддереве листа этой тяжелой группы
        if(tin[group_leaf[i]] &lt= tin[v] && tout[v] &lt= tout[group_leaf[i]]) {
            // обновяем структуру данных для этого листа
            cht[i].del(c[v]);
            cht[i].add(new_val);
        }
    }

    // записываем новое значение в вершину
    c[v] = new_val;
}

int distinct_query(int v) { // запрос количества различных в поддереве вершины v
    int res;    // переменная для результата
    if(sz[v] < H) { // если вершина v легкая
        for(int j = tin[v]; j < tout[v]; j++)
            cht[0].add(c[et[j]]);   // добавляем все вершины из поддерева v в пустую структуру данных

        res = cht[0].get_distinct_count();  // получаем ответ

        for(int j = tin[v]; j < tout[v]; j++)
            cht[0].del(c[et[j]]);   // очищаем структуру данных
    } else {    // если вершина v тяжелая
        int gr = group[v];  // определяем номер группы вершины v
        int leaf = group_leaf[gr];  // и лист этой тяжелой группы

        // добавляем в структуру данных листа все недостающие вершины
        for(int j = tin[v]; j < tin[leaf]; j++)
            cht[gr].add(c[et[j]]);
        for(int j = tout[leaf]; j < tout[v]; j++)
            cht[gr].add(c[et[j]]);

        // получаем ответ
        res = cht[gr].get_distinct_count();

        // возвращаем структуру данных в исходное состояние
        for(int j = tin[v]; j < tin[leaf]; j++)
            cht[gr].del(c[et[j]]);
        for(int j = tout[leaf]; j < tout[v]; j++)
            cht[gr].del(c[et[j]]);
    }

    return res; // возвращаем результат
}

int main() {
    int n, root;
    // считывание количества вершин в дереве и корня дерева
    cin >> n >> root;

    root--;

    H = int(sqrt(n));

    c.resize(n);
    // считывание чисел, записанных в вершинах
    for(int i = 0; i < n; i++) {
        cin >> c[i];
    }

    g.resize(n);
    //считывание ребер дерева
    for(int i = 0; i < n - 1; i++) {
        int v, u;
        cin >> v >> u;

        v--;
        u--;

        g[v].push_back(u);
        g[u].push_back(v);
    }

    sz.resize(n);
    d.resize(n);
    tin.resize(n);
    tout.resize(n);
    par.resize(n);

    dfs(root, 0);

    group.resize(n);

    vector&ltint> ord;
    vector&ltvector&ltint>> pos(n);
    for(int i = 0; i < n; i++) {
        if(sz[i] >= H) {
            pos[d[i]].push_back(i);
            group[i] = -1;
        } else {
            group[i] = 0;
        }
    }

    // стабильная сортировка подсчетом тяжелых вершин по глубине
    for(int i = n - 1; i >= 0; i--) {
        for(int v : pos[i]) {
            ord.push_back(v);
        }
    }

    int cur_ind = 1;
    group_leaf.resize(1);
    group_root.resize(1);
    for(int v : ord) {
        if(group[v] == -1) {
            group_leaf.push_back(v);
            group_root.push_back(v);
            while(sz[v] - sz[group_leaf[cur_ind]] &lt= H) {
                group[v] = cur_ind;
                group_root[cur_ind] = v;

                if(v == root)
                    break;
                else
                    v = par[v];
            }

            cur_ind++;
        }
    }

    group_count = cur_ind;


    cht.resize(group_count);    // структуры данных для поддеревьев листов тяжелых групп
    // перебираем тяжелую группу
    for(int i = 1; i < group_count; i++) {
        // перебираем вершину в поддереве листа текущей тяжелой группы
        for(int j = tin[group_leaf[i]]; j < tout[group_leaf[i]]; j++) {
            cht[i].add(c[et[j]]);   // добавляем значение в этой вершине в соответствующую структуру данных
        }
    }

    int q;
    // считываем количество запросов
    cin >> q;

    int ans = 0;
    for(int i = 0; i < q; i++) {
        int query_type;
        cin >> query_type;

        if(query_type == 1) { // изменить значение в вершине
            int v, new_val;
            cin >> v >> new_val;

            v--;

            update_query(v, new_val);
        } else {    // узнать количество различных в поддереве вершины
            int v;
            cin >> v;

            v--;

            cout &lt< distinct_query(v) &lt< '\n';
        }
    }
}</code></pre>


    <h2 id="pril:B" class="article_h2">Приложение B. Вспомогательная структура данных для поиска моды в мультимножестве</h2>
    <pre><code class="language-cpp">class mode_data_structure {
private:
    int n;  // максимальное количество элементов в структуре
    unordered_map&ltint, int> ht; // ключ - значение в вершине, значение - количество вершин с таким значением
    unordered_map&ltint, list<int>::iterator> ht_it; // ключ - значение в вершине, значение - итератор в соответствующем списке из ht_inv
    int mode_count;         // количество раз, которое встречается мода в текущий момент времени
    vector&ltlist&ltint>> ht_inv;   // в i-ом элементе хранятся все такие x, что ht[x] = i
public:
    mode_data_structure(int n) : mode_count(0) {
        ht_inv.resize(n + 1);
        mode_count = -1;
    };

    void add(int x);    // добавить элемент в структуру

    void del(int x);    // удалить элемент из структуры

    pair&ltint, int> get_mode() {  // получить пару из mode_count и одну из мод элементов в структуре
        if(mode_count == 0)
            return make_pair(0, -1);
        else
            return make_pair(mode_count, ht_inv[mode_count].front());
    }
};

void mode_data_structure::add(int x) {
    int& cnt = ht[x];
    if(ht_it.count(x))
        ht_inv[cnt].erase(ht_it[x]);

    cnt++;

    if(cnt > mode_count) {
        mode_count = cnt;
    }

    ht_inv[cnt].push_front(x);
    ht_it[x] = ht_inv[cnt].begin();
}

void mode_data_structure::del(int x) {
    int& cnt = ht[x];
    ht_inv[cnt].erase(ht_it[x]);

    if(cnt == mode_count && ht_inv[cnt].empty()) {
        mode_count--;
    }

    cnt--;

    if(cnt == 0) {
        ht.erase(x);
        ht_it.erase(x);
    } else {
        ht_inv[cnt].push_front(x);
        ht_it[x] = ht_inv[cnt].begin();
    }
}</code></pre>
</div>