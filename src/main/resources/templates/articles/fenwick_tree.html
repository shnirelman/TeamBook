<div th:fragment="fenwick_tree">
  <h1 class="article_h1"> Дерево Фенвика </h1>

  <h2 class="article_h2" id="prerequisites">Предварительные требования к читателю</h2>
  <ul>
    <li>Префиксные суммы</li>
    <li>Битовые операции (побитовое И, ИЛИ)</li>
  </ul>

  <h2 class="article_h2" id="problem">Постановка задачи</h2>
  Рассмотрим основную задачу, которую решает дерево Фенвика:
  <p>Дан массив \(a\) из \(n\) элементов, к нему поступают \(q\) запросов. Каждый
  запрос может быть одного из двух типов:
  <ul>
    <li>Даны числа \(l\) и \(r\), нужно найти сумму \(a_l+a_{l+1}+...+a_r\) (сумму на отрезке
      массива).</li>
    <li>Даны числа \(i\) и \(x\), нужно сделать присвоение \(a_i = x\).</li>
  </ul>

  Ограничения: \(1 \le n, q \le 10^6, 1 ≤ a_i, x \le 10^9\).


  <h2 class="article_h2" id="algorithm">Описание алгоритма</h2>
  Числа \(n\) и \(q\) слишком большие, чтобы можно было искать сумму простым
  циклом, так что нужно более эффективное решение. Для начала заметим,
  что сумма на отрезке \(a[l..r]\) равна разности двух сумм на отрезках \(a[0..r]\) и
  \(a[0..l − 1]\). Так что сумму на отрезке можно свести к сумме на префиксе, то
  есть на отрезке, начинающемся с нулевого элемента.
  <p>Идея решения в следующем: будем хранить дополнительный массив \(t\),
  в котором будут посчитаны некоторые суммы. А именно, в элементе \(t_i\) будет
  храниться сумма на отрезке \(a[f(i)..i]\), где \(f(i)\) — некоторая функция, которую
  определим позже. Тогда сумма на префиксе \(a[0..r]\) равна сумме \(t_r\) и суммы на
  префиксе \(a[0..f(r) − 1]\). Таким образом, можно уменьшать префикс, пока он
  не станет пустым (пока \(r \ge 0\)).
  <p>Теперь нужно понять, как выполнять запрос второго типа (изменение
  элемента). Для этого нужно пересчитать массив \(t\). Для удобства приведём
  запрос \(a_i = x\) к виду \(a_i = a_i + d\). Теперь в массиве \(t\) нужно прибавить \(d\) ко
  всем элементам, отрезки которых содержат элемент \(i\).
  <p>Определим функцию \(f(i)\) как \(i\&(i + 1)\), где \(\&\) — операция побитового
  И. Тогда \(f(i)\) удаляет из двоичной записи числа \(i\) все последние единицы
  (до первого нуля), заменяя их на нули. Если число чётное (не имеет в конце
  единиц), то функция \(f\) его не изменяет. Примеры: \(f(1001011_2) = 1001000_2,
  f(1100100_2) = 1100100_2\).
  <p>Этого уже достаточно для поиска суммы на префиксе, но осталось понять,
  как выполнять изменение (какие отрезки пересекают данный элемент \(i\)).
  Для примера возьмём \(i = 1001010_2\). Нужно найти все такие индексы, которые
  больше или равны данному, но после применения к ним функции \(f\) становятся
  меньше или равны данному. Подходят следующие числа: \(1001010_2, 1001011_2,
  1001111_2, 1011111_2, 1111111_2\). Дальше можно только увеличивать количество
  единиц.
  <p>Из примера можно увидеть, что индексы изменяемых элементов в \(t\) можно построить следующим образом:
  взять число \(i\) из запроса и заменять его
  нули с конца двоичной записи на единицы. Так как в массиве \(t\) нужно столько
  же элементов, сколько и в исходном массиве \(a\), можно остановить цикл изменения,
  когда индекс выйдет за границу массива \(a\). Чтобы в двоичной записи
  индекса \(x\) заменить последний ноль на единицу, можно использовать формулу
  \(x|(x + 1)\), где \(|\) — побитовое ИЛИ.

  <h2 class="article_h2" id="implementation">Реализация</h2>
  На языке C++ это можно реализовать следующим образом:

  <!-- <div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">vector<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> p(n <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">0</span>);
  <span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> n; i<span style="color: #333333">++</span>)
  p[i <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>] <span style="color: #333333">=</span> p[i] <span style="color: #333333">+</span> a[i];
  </pre></div> --->
  <pre><code class="language-cpp">
  const int N = 1e6 + 5; // константа, которая должна быть не меньше размера массива

  long long t[N]; // конкретно в этой задаче сумма может не поместиться в int

  long long sum(int r) // сумма на префиксе a[0..r]
  {
      long long ans = 0;

      for(; r >= 0; r = (r & r + 1) - 1)
          ans += t[r];

      return ans;
  }

  void inc(int i, int d) // прибавление d к элементу a[i]
  {
      for(; i < N; i |= i + 1)
          t[i] += d;
  }
  </code></pre>


  <h2 class="article_h2" id="complexity_analysis">Оценка времени работы алгоритма</h2>
  <p>Функция \(inc\) на каждой итерации цикла увеличивает количество единиц
  в двоичной записи числа \(i\), поэтому работает за время \(O(log N)\).
  <p>Для оценки функции \(sum\) посмотрим, что происходит с числом \(r + 1\)
  на новой итерации цикла. Если на новой итерации \(r := (r\&r + 1) − 1\), то
  новое значение \(r + 1\) равно старому \(r\&(r + 1)\). Если \(r + 1\) обозначить переменной \(rPlus1\),
  то между итерациями цикла происходит изменение \(rPlus1 =
  (rPlus1 − 1)\&rPlus1\). Эта операция обнуляет в числе \(rPlus1\) последнюю
  единицу (не важно, где она находится). Таким образом, функция \(sum\) делает количество итераций,
  равное количеству единиц в двоичной записи числа
  \(r + 1\), так что работает за время \(O(\log N)\).
  <p>Таким образом, исходная задача может быть решена за время \(O((n +
  q) \log n)\).

</div>