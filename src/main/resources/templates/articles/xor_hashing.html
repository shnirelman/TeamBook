<div th:fragment="xor_hashing">
  <h1 class="article_h1">Алгоритм XOR-хеширования</h1>

  <h2 class="article_h2" id="prerequisites">Предварительные требования к читателю</h2>
  <ul>
    <li>Понимание битовых операций</li>
    <li>Основы хеш-функций и их применения</li>
  </ul>

  <h2 class="article_h2" id="problem">Постановка задачи</h2>
  У вас есть массив \(A\) и \(Q\) запросов, которые проверяют, является ли подмассив от \(l\) до \(r\) ( \(A[l], A[l+1], ..., A[r]\) ) перестановкой.

  <h2 class="article_h2" id="idea">Идея алгоритма</h2>
  Основное наблюдение: имеет значение только набор элементов, порядок не важен. Необходимо выяснить, встречается ли каждый элемент ровно один раз.

  <p>Решение: присвоим случайное число \(randval[i]\) каждому числу \(i\). Тогда можно сказать, что если XOR подмассива \(randval[A[l]] \text{ xor } randval[A[l+1]] \text{ xor } ... \text{ xor } randval[A[r]]\) равен XOR любой перестановки размера \(r-l+1\) (например, \(1, 2, 3, ..., r-l+1\), чей хеш равен \(randval[1] \text{ xor } randval[2] \text{ xor } ... \text{ xor } randval[r-l+1]\)), то подмассив является перестановкой.

  <h2 class="article_h2" id="insights">Некоторые важные моменты</h2>
  При использовании XOR возникает проблема: мы считаем количество встречаемости каждого элемента по модулю 2, а не реальное количество. Однако в этой задаче, если бы элементы повторялись, XOR-хеш никогда бы не совпадал с XOR-хешем последовательности \(1, 2, 3, ..., r-l+1\), так как если бы некоторые числа повторялись, их было бы больше, чем необходимо для перестановки.

  <p>Как альтернатива этой технике можно использовать полиномиальный хеш над бинарной строкой, которая представляет количество вхождений каждого элемента по модулю 2, но XOR-хеширование работает быстрее, с меньшим количеством кода и с меньшей заботой о коллизиях.

  <h2 class="article_h2" id="collisions">Коллизии</h2>
  Теперь поговорим о коллизиях. Поскольку числа случайные, вероятность коллизии в каждом запросе с одним битом составляет 1/2. Так как XOR независим по каждому биту, вероятность коллизии при использовании \(k\) битов равна \(2^{-k}\). Можно использовать 32-битные или 64-битные случайные числа в зависимости от числа требуемых запросов. Поскольку числа генерируются случайным образом, взлом этого хеширования маловероятен, хотя это не гарантия.

  <h2 class="article_h2" id="implementation">Реализация</h2>
  Алгоритм очень прост в реализации. Вот пример на C++:

  <pre><code class="language-cpp">
    vector&ltint> a(n);

    // допустим, в массиве A лежат числа в диапазоне [0, n)

    mt19937_64 mt;
    vector&ltlong long> hash_code(n); // хеш-таблица
    for (int i = 0; i < n; i++)
      hash_code[i] = mt();

    vector&ltlong long> hash_prefix(n+1, 0);
    for (int i = 0; i < n; i++)
      hash_prefix[i+1] = hash_prefix[i] ^ hash_code[a[i]];

    // теперь мы можем отвечать на запросы "хеш на отрезке [l; r]"
    // достаточно просто взять hash_prefix[r] ^ hash_prefix[l-1];

    // допустим, мы теперь хотим отвечать на запрос, является ли отрезок перестановкой
    vector&ltlong long> permutation_hash(n+1, 0);
    for (int i = 0; i < n; i++)
      permutation_hash[i+1] = permutation_hash[i] ^ hash_code[i];

    // теперь необходимо убедиться, что hash_prefix[r] ^ hash_prefix[l-1] == permutation_hash[r-l+1];
  </code></pre>
</div>